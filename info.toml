# The format version is an indicator of the compatibility of community exercises with the
# Rustlings program.
# The format version is not the same as the version of the Rustlings program.
# In case Rustlings makes an unavoidable breaking change to the expected format of community
# exercises, you would need to raise this version and adapt to the new format.
# Otherwise, the newest version of the Rustlings program won't be able to run these exercises.
format_version = 1

welcome_message = """
Це твій перший раз? Не хвилюйся, Rustlings створено для початківців!
Ми навчимо тебе багато чого про Rust, але перш ніж почати,
ось декілька зауважень про те, як працює Rustlings:

1. Центральна концепція Rustlings полягає в тому, що ти розв'язуєш вправи. Ці
   вправи зазвичай містять помилки компілятора або логічні помилки, які призводять до
   невдалої компіляції чи тестування. Твоє завдання - знайти всі помилки
   та виправити їх!
2. Переконайся, що твій редактор відкрито в директорії `rustlings/`. Rustlings
   покаже тобі шлях до поточної вправи під індикатором прогресу. Відкрий
   файл вправи у своєму редакторі, виправ помилки та збережи файл. Rustlings
   автоматично виявить зміну файлу та перезапустить вправу. Якщо всі
   помилки виправлено, Rustlings запропонує тобі перейти до наступної вправи.
3. Якщо ти застряг на вправі, введи `h`, щоб показати підказку.
4. Якщо вправа тобі незрозуміла, сміливо створюй issue на
   GitHub! (https://github.com/rust-lang/rustlings). Ми переглядаємо кожне issue, і
   іноді інші учні теж це роблять, тож ти можеш допомагати один одному!"""

final_message = """
Сподіваємося, тобі сподобалося вивчати різні аспекти Rust!
Якщо ти помітив будь-які проблеми, не соромся повідомити про них на Github.
Ти також можеш внести свої власні вправи, щоб допомогти спільноті!

Перед повідомленням про проблему або внесенням змін, будь ласка, прочитай наші рекомендації:
https://github.com/rust-lang/rustlings/blob/main/CONTRIBUTING.md"""

# INTRO

[[exercises]]
name = "intro1"
dir = "00_intro"
test = false
skip_check_unsolved = true
hint = """
Натисніть `n`, щоб перейти до наступної вправи.
"""

[[exercises]]
name = "intro2"
dir = "00_intro"
test = false
hint = """
Компілятор підказує, що макрос написано неправильно.
Він також пропонує альтернативу."""


# VARIABLES

[[exercises]]
name = "variables1"
dir = "01_variables"
test = false
hint = """
В оголошенні змінної у тілі функції `main` відсутнє ключове слово, яке потрібне
в Rust для створення нового прив'язування змінної (variable binding)."""

[[exercises]]
name = "variables2"
dir = "01_variables"
test = false
hint = """
Повідомлення компілятора говорить, що Rust не може вивести тип (infer the type), який
для прив'язування змінної `x` до значенням, що вказано.

Що станеться, якщо ви анотуєте перший рядок у функції `main` анотацією типу
(type annotation)?

Що, якщо ви дасте `x` значення?

Що, якщо ви зробите і те, і інше?

Якого типу повинен бути `x`?

Що, якщо `x` того самого типу, що й `10`? А якщо іншого типу?"""

[[exercises]]
name = "variables3"
dir = "01_variables"
test = false
hint = """
У цій вправі ми маємо прив'язування змінної, яке ми створили в функції `main`,
і ми намагаємося використати його в наступному рядку, але ми не дали йому
значення.

Ми не можемо вивести щось, чого там немає; спробуйте дати `x` значення!

Це помилка використовувати змінну без ініціалізації, і це може спричинити інші
помилки при виконання програми. Подібне дуже легко зробити в багатьох мовах
програмування — на щастя, компілятор Rust зловив це для нас!"""

[[exercises]]
name = "variables4"
dir = "01_variables"
test = false
hint = """
У Rust прив'язування змінних за замовчуванням є незмінюваними (immutable). Але тут ми намагаємося
переприсвоїти інше значення до `x`! Є ключове слово, яке ми можемо використати, щоб зробити
прив'язування змінної змінюваним (mutable)."""

[[exercises]]
name = "variables5"
dir = "01_variables"
test = false
hint = """
У `variables4` ми вже навчилися робити незмінювану змінну змінюваною
використовуючи спеціальне ключове слово. На жаль, це не дуже допомагає нам у цій
вправі, тому що ми хочемо присвоїти значення іншого типу до існуючої
змінної. Іноді вам також може знадобитися повторно використовувати існуючі імена змінних, тому що
ви просто конвертуєте значення в різні типи, як у цій вправі.

На щастя, Rust має потужне рішення цієї проблеми: 'Затінення/Перекриття' (Shadowing)!
Ви можете прочитати більше про 'Затінення' в розділі книги 'Змінні та
Змінюваність':
https://doc.rust-lang.org/book/ch03-01-variables-and-mutability.html#shadowing

Спробуйте розв'язати цю вправу після цього, використовуючи цю техніку."""

[[exercises]]
name = "variables6"
dir = "01_variables"
test = false
hint = """
Ми знаємо про змінні та змінюваність, але є ще один важливий тип
змінної: константи (constants).

Константи завжди незмінювані. Вони оголошуються з ключовим словом `const`
замість `let`.

Тип констант завжди повинен бути анотований, на відміну від змінних, для яких
компілятор в більшості випадків може вивести тип з контексту використання.

Прочитайте більше про константи та відмінності між змінними та константами
в розділі 'Константи' в розділі книги 'Змінні та Змінюваність':
https://doc.rust-lang.org/book/ch03-01-variables-and-mutability.html#constants"""

