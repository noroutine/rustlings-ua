format_version = 1

welcome_message = """
Це твій перший раз? Не хвилюйся, Rustlings створено для початківців!
Ми навчимо тебе багато чого про Rust, але перш ніж почати,
ось декілька зауважень про те, як працює Rustlings:

1. Центральна концепція Rustlings полягає в тому, що ти розв'язуєш вправи. Ці
   вправи зазвичай містять помилки компілятора або логічні помилки, які призводять до
   невдалої компіляції чи тестування. Твоє завдання - знайти всі помилки
   та виправити їх!
2. Переконайся, що твій редактор відкрито в директорії `rustlings/`. Rustlings
   покаже тобі шлях до поточної вправи під індикатором прогресу. Відкрий
   файл вправи у своєму редакторі, виправ помилки та збережи файл. Rustlings
   автоматично виявить зміну файлу та перезапустить вправу. Якщо всі
   помилки виправлено, Rustlings запропонує тобі перейти до наступної вправи.
3. Якщо ти застряг на вправі, введи `h`, щоб показати підказку.
4. Якщо вправа тобі незрозуміла, сміливо створюй issue на
   GitHub! (https://github.com/rust-lang/rustlings). Ми переглядаємо кожне issue, і
   іноді інші учні теж це роблять, тож ти можеш допомагати один одному!"""

final_message = """
Сподіваємося, тобі сподобалося вивчати різні аспекти Rust!
Якщо ти помітив будь-які проблеми, не соромся повідомити про них на Github.
Ти також можеш внести свої власні вправи, щоб допомогти спільноті!

Перед повідомленням про проблему або внесенням змін, будь ласка, прочитай наші рекомендації:
https://github.com/rust-lang/rustlings/blob/main/CONTRIBUTING.md"""

# INTRO

[[exercises]]
name = "intro1"
dir = "00_intro"
test = false
skip_check_unsolved = true
hint = """
Натисніть `n`, щоб перейти до наступної вправи.
"""

[[exercises]]
name = "intro2"
dir = "00_intro"
test = false
hint = """
Компілятор підказує, що макрос написано неправильно.
Він також пропонує альтернативу."""


# VARIABLES

[[exercises]]
name = "variables1"
dir = "01_variables"
test = false
hint = """
В оголошенні змінної у тілі функції `main` відсутнє ключове слово, яке потрібне
в Rust для створення нового прив'язування змінної (variable binding)."""

[[exercises]]
name = "variables2"
dir = "01_variables"
test = false
hint = """
Повідомлення компілятора говорить, що Rust не може вивести тип (infer the type), який
для прив'язування змінної `x` до значенням, що вказано.

Що станеться, якщо ви анотуєте перший рядок у функції `main` анотацією типу
(type annotation)?

Що, якщо ви дасте `x` значення?

Що, якщо ви зробите і те, і інше?

Якого типу повинен бути `x`?

Що, якщо `x` того самого типу, що й `10`? А якщо іншого типу?"""

[[exercises]]
name = "variables3"
dir = "01_variables"
test = false
hint = """
У цій вправі ми маємо прив'язування змінної, яке ми створили в функції `main`,
і ми намагаємося використати його в наступному рядку, але ми не дали йому
значення.

Ми не можемо вивести щось, чого там немає; спробуйте дати `x` значення!

Це помилка використовувати змінну без ініціалізації, і це може спричинити інші
помилки при виконання програми. Подібне дуже легко зробити в багатьох мовах
програмування — на щастя, компілятор Rust зловив це для нас!"""

[[exercises]]
name = "variables4"
dir = "01_variables"
test = false
hint = """
У Rust прив'язування змінних за замовчуванням є незмінюваними (immutable). Але тут ми намагаємося
переприсвоїти інше значення до `x`! Є ключове слово, яке ми можемо використати, щоб зробити
прив'язування змінної змінюваним (mutable)."""

[[exercises]]
name = "variables5"
dir = "01_variables"
test = false
hint = """
У `variables4` ми вже навчилися робити незмінювану змінну змінюваною
використовуючи спеціальне ключове слово. На жаль, це не дуже допомагає нам у цій
вправі, тому що ми хочемо присвоїти значення іншого типу до існуючої
змінної. Іноді вам також може знадобитися повторно використовувати існуючі імена змінних, тому що
ви просто конвертуєте значення в різні типи, як у цій вправі.

На щастя, Rust має потужне рішення цієї проблеми: 'Затінення/Перекриття' (Shadowing)!
Ви можете прочитати більше про 'Затінення' в розділі книги 'Змінні та
Змінюваність':
https://doc.rust-lang.org/book/ch03-01-variables-and-mutability.html#shadowing

Спробуйте розв'язати цю вправу після цього, використовуючи цю техніку."""

[[exercises]]
name = "variables6"
dir = "01_variables"
test = false
hint = """
Ми знаємо про змінні та змінюваність, але є ще один важливий тип
змінної: константи (constants).

Константи завжди незмінювані. Вони оголошуються з ключовим словом `const`
замість `let`.

Тип констант завжди повинен бути анотований, на відміну від змінних, для яких
компілятор в більшості випадків може вивести тип з контексту використання.

Прочитайте більше про константи та відмінності між змінними та константами
в розділі 'Константи' в розділі книги 'Змінні та Змінюваність':
https://doc.rust-lang.org/book/ch03-01-variables-and-mutability.html#constants"""


# FUNCTIONS

[[exercises]]
name = "functions1"
dir = "02_functions"
test = false
hint = """
Ця функція `main` викликає функцію, яка, як очікується, існує, але
функція не існує. Вона очікує, що ця функція має назву `call_me`.
Вона також очікує, що ця функція не приймає жодних аргументів і не повертає значення.
Звучить дуже схоже на `main`, чи не так?"""

[[exercises]]
name = "functions2"
dir = "02_functions"
test = false
hint = """
Rust вимагає, щоб усі частини сигнатури функції (function's signature) мали анотації типів,
але в `call_me` відсутня анотація типу для `num`."""

[[exercises]]
name = "functions3"
dir = "02_functions"
test = false
hint = """
Цього разу з оголошенням функції (function declaration) все гаразд, але щось не так
з місцем, де ми викликаємо функцію."""

[[exercises]]
name = "functions4"
dir = "02_functions"
test = false
hint = """
Повідомлення про помилку вказує на функцію `sale_price` і каже, що очікується тип
після `->`. Тут має бути тип повернення функції (function's return type).
Подивіться на функцію `is_even` як на приклад!"""

[[exercises]]
name = "functions5"
dir = "02_functions"
test = false
hint = """
Це дуже поширена помилка, яку можна виправити, видаливши один символ.
Це відбувається тому, що Rust розрізняє вирази та інструкції (expressions and statements):
Вирази повертають значення на основі своїх операндів, а інструкції просто
повертають тип `()`, який поводиться як `void` у C/C++.

Ми хочемо повернути значення типу `i32` з функції `square`, але
вона повертає тип `()`.

Є два рішення:
1. Додати ключове слово `return` перед `num * num;`
2. Видалити крапку з комою `;` після `num * num`"""

# IF

[[exercises]]
name = "if1"
dir = "03_if"
hint = """
Це можна зробити в одному рядку, якщо хочете!

Деякі подібні приклади з інших мов:
- У C/C++ це було б: `a > b ? a : b`
- У Python це було б: `a if a > b else b`

Пам'ятайте, що в Rust:
- умова `if` не повинна бути оточена дужками
- умовні конструкції `if`/`else` є виразами (expressions)
- кожна умова супроводжується блоком `{}`"""

[[exercises]]
name = "if2"
dir = "03_if"
hint = """
Стосовно тієї першої помилки компілятора, в Rust важливо, щоб кожен умовний
блок повертав той самий тип!

Щоб тести пройшли, вам знадобиться кілька умов, що перевіряють різні
вхідні значення. Прочитайте тести, щоб дізнатися, що вони очікують."""

[[exercises]]
name = "if3"
dir = "03_if"
hint = """
У Rust кожна гілка виразу `if` має повертати значення того самого типу.
Переконайтеся, що тип узгоджений у всіх гілках."""

# QUIZ 1

[[exercises]]
name = "quiz1"
dir = "quizzes"
hint = "Цього разу без підказок ;)"

# PRIMITIVE TYPES

[[exercises]]
name = "primitive_types1"
dir = "04_primitive_types"
test = false
hint = """
У Rust логічне (булеве, boolean) значення можна заперечити за допомогою оператора `!` перед ним.
Приклад: `!true == false`
Це також працює з булевими змінними."""

[[exercises]]
name = "primitive_types2"
dir = "04_primitive_types"
test = false
hint = "Цього разу без підказок ;)"

[[exercises]]
name = "primitive_types3"
dir = "04_primitive_types"
test = false
hint = """
Є скорочення для ініціалізації масивів (arrays) певного розміру, яке не
вимагає введення 100 елементів (але ви, звичайно, можете, якщо хочете!).

Наприклад, ви можете зробити:
```
let array = ["Are we there yet?"; 100];
```

Бонус: що ще може повертати `true` для `a.len() >= 100`?"""

[[exercises]]
name = "primitive_types4"
dir = "04_primitive_types"
hint = """
Подивіться на розділ 'Understanding Ownership -> Slices -> Other Slices'
книги: https://doc.rust-lang.org/book/ch04-03-slices.html і використайте
початковий та кінцевий (плюс один) індекси елементів у масиві, які ви хочете
отримати в зрізі (slice).

Якщо вам цікаво, чому перший аргумент `assert_eq!` не має
амперсанда для посилання (reference), оскільки другий аргумент є посиланням, подивіться
на розділ Номікону про приведення типів:
https://doc.rust-lang.org/nomicon/coercions.html"""

[[exercises]]
name = "primitive_types5"
dir = "04_primitive_types"
test = false
hint = """
Подивіться на розділ 'Data Types -> The Tuple Type' книги:
https://doc.rust-lang.org/book/ch03-02-data-types.html#the-tuple-type
Особливо на частину про деструктуризацію (destructuring) (передостанній приклад у
розділі).

Вам потрібно створити патерн для прив'язування `name` та `age` до відповідних частин
набору (tuple)."""

[[exercises]]
name = "primitive_types6"
dir = "04_primitive_types"
hint = """
Хоча ви могли б використати деструктуризуючий `let` для кортежу тут, спробуйте
індексацію замість цього, як пояснено в останньому прикладі
розділу 'Data Types -> The Tuple Type' книги:
https://doc.rust-lang.org/book/ch03-02-data-types.html#the-tuple-type
Тепер у вас є ще один інструмент у вашому наборі!"""

# VECS

[[exercises]]
name = "vecs1"
dir = "05_vecs"
hint = """
У Rust є два способи визначити вектор (Vector).
1. Один спосіб — використати функцію `Vec::new()` для створення нового вектора
   і заповнити його методом `push()`.
2. Другий спосіб — використати макрос `vec![]` і визначити ваші елементи
   всередині квадратних дужок. Цей спосіб простіший, коли ви точно знаєте
   початкові значення.

Перевірте цей розділ: https://doc.rust-lang.org/book/ch08-01-vectors.html
книги Rust, щоб дізнатися більше."""

[[exercises]]
name = "vecs2"
dir = "05_vecs"
hint = """
У першій функції ми створюємо порожній вектор і хочемо додати нові елементи
до нього.

У другій функції ми відображаємо значення вхідних даних і збираємо їх у
вектор.

Після завершення з обома функціями вирішіть для себе, який підхід вам
більше подобається.

Як ви думаєте, який патерн більш поширений серед розробників Rust?"""

# MOVE SEMANTICS

[[exercises]]
name = "move_semantics1"
dir = "06_move_semantics"
hint = """
Отже, ви отримали помилку "cannot borrow `vec` as mutable, as it is not declared as
mutable" на рядку, де ми додаємо елемент до вектора, правильно?

Виправлення цього полягає в додаванні одного ключового слова, і додавання НЕ в тому
рядку, де ми додаємо до вектора (де помилка).

Спробуйте отримати доступ до `vec0` після виклику `fill_vec()`. Подивіться, що станеться!"""

[[exercises]]
name = "move_semantics2"
dir = "06_move_semantics"
hint = """
Коли вперше запускаєте цю вправу, ви помітите помилку про
"borrow of moved value". У Rust, коли аргумент передається функції і
він явно не повертається, ви більше не можете використовувати оригінальну змінну.
Ми називаємо це "переміщенням" (moving) змінної. Коли ми передаємо `vec0` у `fill_vec`, воно
"переміщується" в `vec1`, що означає, що ми більше не можемо отримувати доступ до `vec0`.

Ви могли б зробити іншу, окрему версію даних, що знаходяться в `vec0`, і
передати її в `fill_vec` замість цього. Це називається клонуванням (cloning) у Rust."""

[[exercises]]
name = "move_semantics3"
dir = "06_move_semantics"
hint = """
Різниця між цим і попередніми полягає в тому, що перший рядок
`fn fill_vec`, який мав `let mut vec = vec;`, більше не там. Ви можете,
замість додавання того рядка назад, додати `mut` в одному місці, яке змінить
існуюче прив'язування з незмінюваного на змінюване :)"""

[[exercises]]
name = "move_semantics4"
dir = "06_move_semantics"
hint = """
Уважно обміркуйте діапазон, в якому кожне змінюване посилання (mutable reference) знаходиться в
області видимості. Чи допомагає оновити значення `x` відразу після
взяття змінюваного посилання?
Прочитайте більше про 'Змінювані посилання' в розділі книги 'Посилання та
Запозичення':
https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html#mutable-references."""

[[exercises]]
name = "move_semantics5"
dir = "06_move_semantics"
test = false
hint = """
Щоб знайти відповідь, ви можете звернутися до розділу книги "Посилання та запозичення":
https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html

Перша проблема полягає в тому, що `get_char` бере володіння (ownership) рядка. Отже,
`data` переміщується і не може використовуватися для `string_uppercase`. `data` переміщується до
`get_char` спочатку, що означає, що `string_uppercase` не може маніпулювати даними.

Як тільки ви це виправите, сигнатуру функції `string_uppercase` також потрібно буде
скоригувати."""

# STRUCTS

[[exercises]]
name = "structs1"
dir = "07_structs"
hint = """
Rust має більше ніж один тип структури (struct). Насправді три, всі варіанти використовуються для
упакування пов'язаних даних разом.

Є звичайні структури. Це іменовані колекції пов'язаних даних, що зберігаються в
полях.

Структурні набори (Tuple structs) — це в основному просто іменовані набори.

Нарешті, одиничні структури (unit structs). Вони не мають жодних полів і корисні для дженериків.

У цій вправі вам потрібно завершити та реалізувати по одному з кожного виду.
Прочитайте більше про структури в Книзі:
https://doc.rust-lang.org/book/ch05-01-defining-structs.html"""

[[exercises]]
name = "structs2"
dir = "07_structs"
hint = """
Створення екземплярів структур просте, все, що вам потрібно зробити, це присвоїти деякі значення
їх полям.

Однак є деякі скорочення, які можна використати при створенні екземплярів структур.
Подивіться в Книзі, щоб дізнатися більше:
https://doc.rust-lang.org/book/ch05-01-defining-structs.html#creating-instances-from-other-instances-with-struct-update-syntax"""

[[exercises]]
name = "structs3"
dir = "07_structs"
hint = """
Для `is_international`: Що робить пакет міжнародним? Здається, це пов'язано з
місцями, через які він проходить, правильно?

Для `get_fees`: Цей метод приймає додатковий аргумент, чи є поле в
структурі `Package`, до якого це стосується?

Подивіться в Книзі, щоб дізнатися більше про реалізацію методів:
https://doc.rust-lang.org/book/ch05-03-method-syntax.html"""

# ENUMS

[[exercises]]
name = "enums1"
dir = "08_enums"
test = false
hint = "Цього разу без підказок ;)"

[[exercises]]
name = "enums2"
dir = "08_enums"
test = false
hint = """
Ви можете створювати перерахування (enumerations), які мають різні варіанти з різними типами,
такими як анонімні структури, звичайні структури, один рядок, набори, зовсім без даних тощо."""

[[exercises]]
name = "enums3"
dir = "08_enums"
hint = """
Як перший крок, визначте enum'и для компіляції коду без помилок.

Потім створіть вираз match у `process()`.

Зауважте, що вам потрібно деконструювати деякі варіанти повідомлень у виразі match,
щоб отримати значення варіанта."""

# STRINGS

[[exercises]]
name = "strings1"
dir = "09_strings"
test = false
hint = """
Функція `current_favorite_color` наразі повертає рядковий зріз (string slice)
з часом життя `'static`. Ми це знаємо, тому що дані рядка живуть
у нашому коді — вони не походять з файлу чи введення користувача чи іншої
програми — тому вони житимуть стільки, скільки живе наша програма.

Але це все ще рядковий зріз. Є один спосіб створити `String`, перетворивши рядковий зріз, описаний у розділі Strings книги, і
інший спосіб, який використовує трейт `From`."""

[[exercises]]
name = "strings2"
dir = "09_strings"
test = false
hint = """
Так, було б дуже легко виправити це, просто змінивши значення, прив'язане до
`word`, щоб воно було рядковим зрізом замість `String`, чи не так? Є спосіб
додати один символ до інструкції `if`, який приведе
`String` до рядкового зрізу.

Примітка: Якщо вас цікавить, як працює такий тип перетворення посилань,
ви можете перейти вперед у книзі та прочитати цю частину в розділі про розумні покажчики:
https://doc.rust-lang.org/book/ch15-02-deref.html#implicit-deref-coercions-with-functions-and-methods"""

[[exercises]]
name = "strings3"
dir = "09_strings"
hint = """
Є багато корисних функцій стандартної бібліотеки для рядків. Спробуймо використати
деякі з них:
https://doc.rust-lang.org/std/string/struct.String.html#method.trim

Для методу `compose_me`: Ви можете використати макрос `format!` або перетворити
рядковий зріз у власний рядок, який потім можете вільно розширювати.

Для методу `replace_me` ви можете перевірити метод `replace`:
https://doc.rust-lang.org/std/string/struct.String.html#method.replace"""

[[exercises]]
name = "strings4"
dir = "09_strings"
test = false
hint = """
Замініть `placeholder` на `string` або `string_slice` у функції `main`.

Приклад:
`placeholder("blue");`
має стати
`string_slice("blue");`
тому що "blue" є `&str`, а не `String`."""

# MODULES

[[exercises]]
name = "modules1"
dir = "10_modules"
test = false
hint = """
Все в Rust за замовчуванням є приватним. Але є ключове слово, яке ми можемо використати,
щоб зробити щось публічним!"""

[[exercises]]
name = "modules2"
dir = "10_modules"
test = false
hint = """
Модуль `delicious_snacks` намагається представити зовнішній інтерфейс, який
відрізняється від його внутрішньої структури (модулі `fruits` і `veggies`
та пов'язані константи). Завершіть інструкції `use`, щоб відповідати використанню в
`main`, і знайдіть одне ключове слово, яке відсутнє для обох констант.

Дізнайтеся більше в Книзі:
https://doc.rust-lang.org/book/ch07-04-bringing-paths-into-scope-with-the-use-keyword.html#re-exporting-names-with-pub-use"""

[[exercises]]
name = "modules3"
dir = "10_modules"
test = false
hint = """
`UNIX_EPOCH` і `SystemTime` оголошені в модулі `std::time`. Додайте
інструкцію `use` для цих двох, щоб ввести їх в область видимості. Ви можете використати вкладені
шляхи, щоб ввести обидва, використовуючи лише один рядок."""

# HASHMAPS

[[exercises]]
name = "hashmaps1"
dir = "11_hashmaps"
hint = """
Кількість фруктів має бути принаймні 5, і ви повинні покласти принаймні 3 типи різних фруктів."""

[[exercises]]
name = "hashmaps2"
dir = "11_hashmaps"
hint = """
Використайте методи `entry()` і `or_insert()` з `HashMap` для досягнення цього.

Дізнайтеся більше в Книзі:
https://doc.rust-lang.org/book/ch08-03-hash-maps.html#only-inserting-a-value-if-the-key-has-no-value"""

[[exercises]]
name = "hashmaps3"
dir = "11_hashmaps"
hint = """
Підказка 1: Використайте методи `entry()` і `or_default()` з `HashMap`, щоб вставити
        значення за замовчуванням `TeamScores`, якщо команди ще немає в таблиці.

Підказка 2: Якщо вже є запис для даного ключа, значення, повернене
        `entry()`, може бути оновлене на основі існуючого значення.

Дізнайтеся більше в Книзі:
https://doc.rust-lang.org/book/ch08-03-hash-maps.html#updating-a-value-based-on-the-old-value"""

# QUIZ 2

[[exercises]]
name = "quiz2"
dir = "quizzes"
hint = "Оператор `+` може з'єднати `String` з `&str`."

# OPTIONS

[[exercises]]
name = "options1"
dir = "12_options"
hint = """
Options можуть мати значення `Some` з внутрішнім значенням або значення `None`
без внутрішнього значення.

Є кілька способів отримати внутрішнє значення, ви можете використати `unwrap` або
зіставлення зразків (pattern match). Unwrapping найпростіший, але як зробити це безпечно, щоб
воно не панікувало пізніше?"""

[[exercises]]
name = "options2"
dir = "12_options"
hint = """
Перевірте:

- https://doc.rust-lang.org/rust-by-example/flow_control/if_let.html
- https://doc.rust-lang.org/rust-by-example/flow_control/while_let.html

Пам'ятайте, що `Option`и можуть бути вкладені в інструкції if-let і while-let.

Наприклад: `if let Some(Some(x)) = y`

Також дивіться `Option::flatten`"""

[[exercises]]
name = "options3"
dir = "12_options"
test = false
hint = """
Компілятор каже, що відбулося часткове переміщення в інструкції `match`. Як цього
можна уникнути? Компілятор показує необхідне виправлення.

Після внесення виправлення, як запропоновано компілятором, прочитайте відповідну сторінку документації:
https://doc.rust-lang.org/std/keyword.ref.html"""

# ERROR HANDLING

[[exercises]]
name = "errors1"
dir = "13_error_handling"
hint = """
`Ok` і `Err` — це два варіанти `Result`, тому те, що кажуть тести,
полягає в тому, що `generate_nametag_text` має повертати `Result` замість `Option`.

Щоб зробити цю зміну, вам потрібно:
  - оновити тип повернення в сигнатурі функції на `Result<String,
    String>`, який може бути варіантами `Ok(String)` і `Err(String)`
  - змінити тіло функції, щоб повертати `Ok(…)` там, де воно наразі
    повертає `Some(…)`
  - змінити тіло функції, щоб повертати `Err(error message)` там, де воно
    наразі повертає `None`"""

[[exercises]]
name = "errors2"
dir = "13_error_handling"
hint = """
Один спосіб обробити це — використовувати інструкцію `match` на
`item_quantity.parse::<i32>()`, де випадки `Ok(something)` і
`Err(something)`.

Однак цей патерн дуже поширений у Rust, тому є оператор `?`, який
робить майже те, що ви б зробили з тією інструкцією match!

Подивіться на цей розділ глави "Обробка помилок":
https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html#a-shortcut-for-propagating-errors-the--operator"""

[[exercises]]
name = "errors3"
dir = "13_error_handling"
test = false
hint = """
Якщо інші функції можуть повертати `Result`, чому не `main`? Це досить
поширена конвенція повертати щось на кшталт `Result<(), ErrorType>` з вашої
функції `main`.

Одиничний тип `()` там тому, що нічого дійсно не потрібно в плані
позитивного результату."""

[[exercises]]
name = "errors4"
dir = "13_error_handling"
hint = """
`PositiveNonzeroInteger::new` завжди створює новий екземпляр і повертає
результат `Ok`. Але воно має виконувати якусь перевірку, повертаючи `Err`, якщо
ці перевірки не вдаються, і повертаючи `Ok` лише якщо ці перевірки визначають, що
все… гаразд :)"""

[[exercises]]
name = "errors5"
dir = "13_error_handling"
test = false
hint = """
Є два різних можливих типи `Result`, що виробляються в функції `main`,
які поширюються за допомогою операторів `?`. Як оголосити тип повернення
для функції `main`, який дозволяє обидва?

Під капотом оператор `?` викликає `From::from` на значенні помилки, щоб
перетворити його на упакований трейт-об'єкт, `Box<dyn Error>`. Цей упакований трейт-об'єкт
є поліморфним, і оскільки всі помилки реалізують трейт `Error`, ми можемо захопити
багато різних помилок в одному об'єкті `Box`.

Перевірте цей розділ Книги:
https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html#a-shortcut-for-propagating-errors-the--operator

Прочитайте більше про упакування помилок:
https://doc.rust-lang.org/stable/rust-by-example/error/multiple_error_types/boxing_errors.html

Прочитайте більше про використання оператора `?` з упакованими помилками:
https://doc.rust-lang.org/stable/rust-by-example/error/multiple_error_types/reenter_question_mark.html"""

[[exercises]]
name = "errors6"
dir = "13_error_handling"
hint = """
Ця вправа використовує завершену версію `PositiveNonzeroInteger` з
попередніх вправ.

Нижче рядка, який `TODO` просить вас змінити, є приклад використання
методу `map_err()` на `Result` для перетворення одного типу помилки в
інший. Спробуйте використати щось подібне на `Result` з `parse()`. Потім ви можете
використати оператор `?` для раннього повернення.

Прочитайте більше про `map_err()` в документації `std::result`:
https://doc.rust-lang.org/std/result/enum.Result.html#method.map_err"""

# Generics

[[exercises]]
name = "generics1"
dir = "14_generics"
test = false
hint = """
Вектори в Rust використовують дженерики (generics) для створення динамічно розмірних масивів будь-якого
типу.
Якщо вектор `numbers` має тип `Vec<T>`, то ми можемо додавати лише значення
типу `T` до нього. Використовуючи `into()` перед додаванням, ми просимо компілятор перетворити
`n1` і `n2` до `T`. Але компілятор ще не знає, що таке `T`, і потребує
анотації типу.

`u8` і `i8` можуть бути перетворені в `i16`, `i32` і `i64`. Виберіть один для
дженерика вектора."""

[[exercises]]
name = "generics2"
dir = "14_generics"
hint = """
Відповідний розділ у Книзі:
https://doc.rust-lang.org/book/ch10-01-syntax.html#in-method-definitions"""

# TRAITS

[[exercises]]
name = "traits1"
dir = "15_traits"
hint = """
Більше про трейти в Книзі:
https://doc.rust-lang.org/book/ch10-02-traits.html

Оператор `+` може з'єднати `String` з `&str`."""

[[exercises]]
name = "traits2"
dir = "15_traits"
hint = """
Зауважте, як трейт бере володіння `self` і повертає `Self`.

Хоча сигнатура `append_bar` у трейті приймає `self` як аргумент,
реалізація може приймати `mut self` замість цього. Це можливо, тому що
значення все одно належить."""

[[exercises]]
name = "traits3"
dir = "15_traits"
hint = """
Трейти можуть мати реалізацію за замовчуванням для функцій. Типи даних, які
реалізують трейт, можуть використовувати версію за замовчуванням цих функцій,
якщо вони вирішують не реалізовувати функцію самостійно.

Відповідний розділ у Книзі:
https://doc.rust-lang.org/book/ch10-02-traits.html#default-implementations"""

[[exercises]]
name = "traits4"
dir = "15_traits"
hint = """
Замість використання конкретних типів як параметрів ви можете використовувати трейти. Спробуйте замінити
`???` на `impl [що тут має бути?]`.

Відповідний розділ у Книзі:
https://doc.rust-lang.org/book/ch10-02-traits.html#traits-as-parameters"""

[[exercises]]
name = "traits5"
dir = "15_traits"
hint = """
Щоб забезпечити, що параметр реалізує кілька трейтів, використайте синтаксис '+'. Спробуйте
замінити `???` на 'impl [що тут має бути?] + [що тут має бути?]'.

Відповідний розділ у Книзі:
https://doc.rust-lang.org/book/ch10-02-traits.html#specifying-multiple-trait-bounds-with-the--syntax"""

# QUIZ 3

[[exercises]]
name = "quiz3"
dir = "quizzes"
hint = """
Щоб знайти найкраще рішення цього завдання, вам потрібно згадати ваші знання
про трейти, зокрема "Синтаксис обмежень трейтів":
https://doc.rust-lang.org/book/ch10-02-traits.html#trait-bound-syntax

Ось як вказати обмеження трейту для блоку реалізації:
`impl<T: Trait1 + Trait2 + …> for Foo<T> { … }`

Вам може знадобитися це:
`use std::fmt::Display;`"""

# LIFETIMES

[[exercises]]
name = "lifetimes1"
dir = "16_lifetimes"
hint = """
Нехай компілятор вас направляє. Також подивіться на Книгу, якщо потрібна допомога:
https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html"""

[[exercises]]
name = "lifetimes2"
dir = "16_lifetimes"
test = false
hint = """
Пам'ятайте, що загальний час життя (generic lifetime) `'a` отримає конкретний час життя, який
дорівнює меншому з часів життя `x` і `y`.

Ви можете обрати принаймні два шляхи для досягнення бажаного результату, зберігаючи
внутрішній блок:
1. Перемістити оголошення `string2`, щоб воно жило так довго, як `string1` (як
   оголошено `result`?)
2. Перемістити `println!` у внутрішній блок"""

[[exercises]]
name = "lifetimes3"
dir = "16_lifetimes"
test = false
hint = """Нехай компілятор вас направляє :)"""

# TESTS

[[exercises]]
name = "tests1"
dir = "17_tests"
hint = """
`assert!` — це макрос, який потребує аргумент. Залежно від значення
аргументу, `assert!` нічого не робитиме (у цьому випадку тест пройде) або
`assert!` запанікує (у цьому випадку тест не пройде).

Тому спробуйте дати різні значення `assert!` і подивіться, які компілюються, які
проходять, а які не проходять :)

Якщо ви хочете перевірити на `false`, ви можете заперечити результат того, що ви
перевіряєте, використовуючи `!`, наприклад `assert!(!…)`."""

[[exercises]]
name = "tests2"
dir = "17_tests"
hint = """
`assert_eq!` — це макрос, який приймає два аргументи і порівнює їх. Спробуйте дати
йому два значення, які рівні! Спробуйте дати йому два аргументи, які різні!
Спробуйте поміняти місцями, який аргумент йде першим, а який другим!"""

[[exercises]]
name = "tests3"
dir = "17_tests"
hint = """
Ми очікуємо, що метод `Rectangle::new` запанікує для від'ємних значень.

Щоб обробити це, вам потрібно додати спеціальний атрибут до тестової функції.

Ви можете звернутися до документації:
https://doc.rust-lang.org/book/ch11-01-writing-tests.html#checking-for-panics-with-should_panic"""

# STANDARD LIBRARY TYPES

[[exercises]]
name = "iterators1"
dir = "18_iterators"
hint = """
Ітератор (iterator) проходить через всі елементи в колекції, але що, якщо у нас закінчилися
елементи? Чого ми маємо очікувати тут? Якщо ви застрягли, подивіться на
https://doc.rust-lang.org/std/iter/trait.Iterator.html"""

[[exercises]]
name = "iterators2"
dir = "18_iterators"
hint = """
`capitalize_first`:

Змінна `first` є `char`. Її потрібно перевести в верхній регістр і додати до
решти символів у `chars`, щоб повернути правильний `String`.

Решту символів у `chars` можна розглядати як рядковий зріз, використовуючи метод
`as_str`.

Документація для `char` містить багато корисних методів.
https://doc.rust-lang.org/std/primitive.char.html

Використайте `char::to_uppercase`. Він повертає ітератор, який можна перетворити на
`String`.

`capitalize_words_vector`:

Створіть ітератор із зрізу. Перетворіть ітеровані значення, застосувавши
функцію `capitalize_first`. Не забудьте `collect` ітератор.

`capitalize_words_string`:

Це дивно схоже на попереднє рішення. `collect` дуже
потужний і дуже загальний. Rust просто потрібно знати бажаний тип."""

[[exercises]]
name = "iterators3"
dir = "18_iterators"
hint = """
Функція `divide` повинна повертати правильну помилку, коли дільник дорівнює 0 або
коли рівне ділення неможливе.

Змінна `division_results` повинна бути зібрана в тип колекції.

Функція `result_with_list` повинна повертати єдиний `Result`, де
випадок успіху — це вектор цілих чисел, а випадок невдачі — це `DivisionError`.

Функція `list_of_results` повинна повертати вектор результатів.

Дивіться https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.collect для
того, як трейт `FromIterator` використовується в `collect()`. Цей трейт ДІЙСНО
потужний! Він може зробити рішення цієї вправи набагато простішим."""

[[exercises]]
name = "iterators4"
dir = "18_iterators"
hint = """
В імперативній мові ви могли б написати цикл `for`, який оновлює змінювану
змінну. Або ви могли б написати код, що використовує рекурсію та клаузулу match. У
Rust ви можете обрати інший функціональний підхід, обчислюючи факторіал
елегантно з діапазонами та ітераторами.

Перевірте методи `fold` і `rfold`!"""

[[exercises]]
name = "iterators5"
dir = "18_iterators"
hint = """
Документація для трейту `std::iter::Iterator` містить численні методи,
які були б корисні тут.

Змінна `collection` у `count_collection_iterator` — це зріз
`HashMap`ів. Її потрібно перетворити на ітератор, щоб використовувати
методи ітератора.

Метод `fold` може бути корисним у функції `count_collection_iterator`.

Для додаткового виклику зверніться до документації `Iterator`, щоб знайти
інший метод, який міг би зробити ваш код більш компактним, ніж використання `fold`."""

# SMART POINTERS

[[exercises]]
name = "box1"
dir = "19_smart_pointers"
hint = """
Повідомлення компілятора має допомогти: Оскільки ми не можемо зберігати значення
фактичного типу при роботі з рекурсивними типами, нам потрібно зберігати посилання
(покажчик) на його значення.

Тому ми маємо помістити наш `List` всередину `Box`. Більше деталей у Книзі:
https://doc.rust-lang.org/book/ch15-01-box.html#enabling-recursive-types-with-boxes

Створення порожнього списку має бути досить простим (Підказка: Прочитайте тести).

Для непорожнього списку пам'ятайте, що ми хочемо використовувати наш конструктор списку `Cons`.
Хоча поточний список складається з цілих чисел (`i32`), не соромтеся змінити
визначення та спробувати інші типи!"""

[[exercises]]
name = "rc1"
dir = "19_smart_pointers"
hint = """
Це проста вправа для використання типу `Rc<T>`. Кожна `Planet` має
володіння `Sun` і використовує `Rc::clone()` для збільшення лічильника посилань
`Sun`.

Після використання `drop()` для виведення `Planet`ів з області видимості окремо,
лічильник посилань зменшується.

Зрештою, `Sun` має лише одне посилання, на себе.

Дивіться більше на: https://doc.rust-lang.org/book/ch15-04-rc.html

На жаль, Плутон більше не вважається планетою :("""

[[exercises]]
name = "arc1"
dir = "19_smart_pointers"
test = false
hint = """
Зробіть `shared_numbers` `Arc` з вектора `numbers`. Тоді, щоб
уникнути створення копії `numbers`, вам потрібно буде створити `child_numbers`
всередині циклу, але все ще в основному потоці.

`child_numbers` має бути клоном `Arc` чисел замість локальної копії чисел у потоці.

Це проста вправа, якщо ви розумієте основні концепції, але якщо це
занадто складно, розгляньте прочитання всього розділу 16 у Книзі:
https://doc.rust-lang.org/book/ch16-00-concurrency.html"""

[[exercises]]
name = "cow1"
dir = "19_smart_pointers"
hint = """
Якщо `Cow` вже володіє даними, йому не потрібно клонувати їх, коли викликається `to_mut()`.

Перевірте документацію типу `Cow`:
https://doc.rust-lang.org/std/borrow/enum.Cow.html"""

# THREADS

[[exercises]]
name = "threads1"
dir = "20_threads"
test = false
hint = """
`JoinHandle` — це структура, яка повертається зі створеного потоку:
https://doc.rust-lang.org/std/thread/fn.spawn.html

Виклик у багатопотокових додатках полягає в тому, що основний потік може
завершитися до того, як створені потоки закінчать роботу.
https://doc.rust-lang.org/book/ch16-01-threads.html#waiting-for-all-threads-to-finish-using-join-handles

Використайте `JoinHandle`и, щоб дочекатися завершення кожного потоку та зібрати їх
результати.

https://doc.rust-lang.org/std/thread/struct.JoinHandle.html"""

[[exercises]]
name = "threads2"
dir = "20_threads"
test = false
hint = """
`Arc` — це атомний лічильник посилань (Atomic Reference Counted), який дозволяє безпечний, спільний доступ
до **незмінюваних** даних. Але ми хочемо *змінити* кількість `jobs_done`, тому
нам потрібно також використати інший тип, який дозволить лише одному потоку змінювати
дані одночасно. Подивіться на цей розділ книги:
https://doc.rust-lang.org/book/ch16-03-shared-state.html#atomic-reference-counting-with-arct

Продовжуйте читати, якщо хочете більше підказок :)

Чи є у вас тепер `Arc<Mutex<JobStatus>>` на початку `main`? Наприклад:
```
let status = Arc::new(Mutex::new(JobStatus { jobs_done: 0 }));
```

Подібно до коду в наступному прикладі в Книзі:
https://doc.rust-lang.org/book/ch16-03-shared-state.html#sharing-a-mutext-between-multiple-threads"""

[[exercises]]
name = "threads3"
dir = "20_threads"
hint = """
Альтернативний спосіб обробки одночасності між потоками — використання каналу `mpsc`
(кілька виробників, один споживач) для спілкування.

З відправним і приймальним кінцем можна відправляти значення в
одному потоці та отримувати їх в іншому.

Кілька виробників можливі за допомогою `clone()` для створення дубліката
оригінального відправного кінця.

Відповідний розділ у Книзі:
https://doc.rust-lang.org/book/ch16-02-message-passing.html"""

# MACROS

[[exercises]]
name = "macros1"
dir = "21_macros"
test = false
hint = """
Коли ви викликаєте макрос, вам потрібно додати щось особливе порівняно із звичайним
викликом функції."""

[[exercises]]
name = "macros2"
dir = "21_macros"
test = false
hint = """
Макроси не зовсім грають за тими самими правилами, що й решта Rust, з точки зору
того, що доступно де.

На відміну від інших речей у Rust, порядок "де ви визначаєте макрос" проти
"де ви його використовуєте" насправді має значення."""

[[exercises]]
name = "macros3"
dir = "21_macros"
test = false
hint = """
Щоб використовувати макрос поза його модулем, вам потрібно зробити щось
особливе з модулем, щоб підняти макрос у його батьківський модуль."""

[[exercises]]
name = "macros4"
dir = "21_macros"
test = false
hint = """
Вам потрібно лише додати один символ, щоб це скомпілювалося.

Спосіб написання макросів такий, що він хоче бачити щось між кожною "гілкою макроса",
щоб він міг їх розділити.

Це всі вправи з макросів, які у нас є, але це ледве торкається
поверхні того, що ви можете робити з макросами Rust. Для більш ґрунтовного
введення ви можете прочитати 'The Little Book of Rust Macros':
https://veykril.github.io/tlborm/"""

#  CLIPPY

[[exercises]]
name = "clippy1"
dir = "22_clippy"
test = false
strict_clippy = true
hint = """
Rust зберігає версії найвищої точності деяких довгих або нескінченно точних
математичних констант у стандартній бібліотеці Rust:
https://doc.rust-lang.org/stable/std/f32/consts/index.html

Ми можемо спокуситися використовувати наші власні наближення для певних математичних
констант, але clippy розпізнає ці неточні математичні константи як джерело
потенційної помилки.

Дивіться пропозиції попередження Clippy у виході компіляції та використайте
відповідну константу заміни з `std::f32::consts`."""

[[exercises]]
name = "clippy2"
dir = "22_clippy"
test = false
strict_clippy = true
hint = """
Цикли `for` над значеннями `Option` більш чітко виражені як інструкція `if-let`.

Не обов'язково для розв'язання цієї вправи, але якщо вас цікавить, коли ітерація
над `Option` може бути корисною, прочитайте наступний розділ у документації:
https://doc.rust-lang.org/std/option/#iterating-over-option"""

[[exercises]]
name = "clippy3"
dir = "22_clippy"
test = false
strict_clippy = true
hint = "Цього разу без підказок!"

# TYPE CONVERSIONS

[[exercises]]
name = "using_as"
dir = "23_conversions"
hint = """
Використайте оператор `as` для приведення одного з операндів в останньому рядку
функції `average` до очікуваного типу повернення."""

[[exercises]]
name = "from_into"
dir = "23_conversions"
hint = """
Виконайте кроки, надані безпосередньо перед реалізацією `From`."""

[[exercises]]
name = "from_str"
dir = "23_conversions"
hint = """
Реалізація `FromStr` має повертати `Ok` з об'єктом `Person`
або `Err` з помилкою, якщо рядок недійсний.

Це майже як попередня вправа `from_into`, але повертає помилки
замість повернення до значення за замовчуванням.

Ще одна підказка: Ви можете використати метод `map_err` з `Result` з функцією або
замиканням для обгортання помилки з `parse::<u8>`.

Ще одна підказка: Якщо ви хочете поширювати помилки за допомогою оператора `?`
у вашому рішенні, ви можете захотіти подивитися на
https://doc.rust-lang.org/stable/rust-by-example/error/multiple_error_types/reenter_question_mark.html"""

[[exercises]]
name = "try_from_into"
dir = "23_conversions"
hint = """
Чи є реалізація `TryFrom` у стандартній бібліотеці, яка може як виконати
необхідне перетворення цілого числа, так і перевірити діапазон вхідних даних?

Виклик: Чи можете ви зробити реалізації `TryFrom` загальними для багатьох типів
цілих чисел?"""

[[exercises]]
name = "as_ref_mut"
dir = "23_conversions"
hint = """
Додайте `AsRef<str>` або `AsMut<u32>` як обмеження трейту до функцій."""